\documentclass[a4paper,12pt]{article}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage{polski}
\usepackage{verbatim}
\usepackage{graphicx}

\newcommand{\readslide}{\vspace{0.2cm} \noindent {\em czytaj ze slajdu} \vspace{0.2cm}}
\newcommand{\insertimg}[1]{\vspace{0.2cm} \noindent {\em Tutaj wstaw rysunek #1} \vspace{0.2cm}}

\title{Dynamic Reachability \\ Plan referatu}

\author{M.~K.~Karpiński}

\begin{document}

\maketitle

\section*{Slajd 1}

Na dzisiejszym seminarium zajmiemy się dobrze znanym problemem grafowym. Mianowicie będzie to problem Silnie spójnych składowych.

\section*{Slajd 2}

\readslide

\noindent \noindent Ponadto dla mojej wygody zamiast mówić co chwilę SSS, będą mówił po prostu {\em komponent}. Gdybym co chwilę mówił silnie spójna składowa, to w końcu ugryzł bym się w język.

\section*{Slajd 3}

\readslide

\noindent Jednak - jak sugeruje tytuł mojego wystąpienia - nas dzisiaj będzie interesować wersja dynamiczna problemu. Co to dokładnie oznacza?

\section*{Slajd 4}

\readslide

\noindent Oczywiście chcemy, aby czasy wykonania tych operacji były jak najmniejsze.


\section*{Slajd 5}

Algorytm, który za chwilę zaprezentuję ma pewną ciekawą własność, którą w jasny sposób opisują operacje jakie będziemy chcieli wykonywać. Oto one:

\readslide

\noindent Zauważmy, że mamy do czynienia z pewnym uproszczeniem: nie ma tutaj mowy o usuwaniu i dodawaniu wierzchołków. Operujemy jedynie na krawędziach. Autorzy pracy nie tłumaczą się z tego, ale domyślam się, że dodawanie wierzchołka jest trywialne, a usuwanie wierzchołka jest równoważne usunięciu wszystkich krawędzi wchodzących i wychodzących z tego wierzchołka. Więc wszystko sprowadza się do operacji na krawędziach.

\section*{Slajd 6}

Jeszcze raz, tylko bardziej formalnie:

\readslide

\noindent Dobrze byłoby narysować przykład, aby aby dokładniej zrozumieć ideę algorytmu.

\insertimg{1}. Z komentarzem. Bez lasu!!

\section*{Slajd 7}

Z tego wynika, że komponenty możemy pamiętać w strukturze Union-Find, która jest dobrze znana z AISDu.

\readslide

\insertimg{1}. Las!!

\section*{Slajd 8}

\readslide

\noindent Aby efektywnie przechowywać taki las komponentów, zdefiniujemy następujący podział krawędzi wszystich wersji grafu:

\section*{Slajd 9}

\readslide

\noindent Na slajdzie może to wyglądać zbyt skomplikowanie, dlatego skorzystam z naszego przykładu, aby rozjaśnić tą definicję.

\insertimg{1.2} Zbiory $H_1 \cdots H_{t+1}$.

\section*{Slajd 10}

Z podanej definicji widać, że podział krawędzi ma następujące własnośći:

\readslide

\section*{Slajd 11}

Oprócz zużycia pamięci na struktury Union-Finda, LCA i podziału dynamicznego, dodatkowo zarezerwujemy sobie pamięć na dwie tablice:

\readslide

Teraz przechodzimy do włąściwego algorytmu.

\section*{Slajd 12}

\readslide

\section*{Slajd 13}

Następnie przyjrzyjmy się operacji Insert.

\readslide i w ogole improwizuj

\section*{Slajd 14}

\section*{Slajd 15}

\section*{Slajd 16}

\readslide

\noindent Z naszą strukturą możemy się jeszcze chwilę pobawić. Możemy np. wypisać na jakie komponenty rozłożył się stary komponent, po dokonaniu operacji Delete. Aby tego dokonać rozwarzmy dwa stany lasu komponentów, pierwszy - przed operacją Delete, drugi - zaraz po operacji Delete.

\section*{Slajd 17}

\insertimg{ten na kartce kratkowanej}

\readslide

\section*{Slajd 18}

\readslide

\insertimg{wraz ze wskaźnikami}

\section*{Slajd 19}

\readslide

Procedura jest raczej prosta. Zaczynając obliczać $Parts(v)$ zakładamy, że $Parts(v')$ zostało już wcześniej obliczone, dla każdego $v' \in children[v]$. $S$ jest zbiorem wynikowym. Od razu można stwierdzić, że wskaźniki dzieci komponentu $v$, są dobrymi kandydatami na bycie wskaźnikami komponentu $v$, wszak wszystkie kompononty z $S$ zawierają się w $v$. Ale oczywiście te komponenty nie muszą być maksymalne. Dlatego algorytm zachowuje zbiór $T$ zawierający wszystkich rodziców komponentów z $S$, które jeszcze nie zostały określone jako maksymalne.

\end{document}
